<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integreat! - Calculus Roguelike</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
            user-select: none;
        }

        /* Card Animations */
        .card {
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s;
        }
        .card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.5);
            z-index: 10;
        }
        .card.dragging {
            opacity: 0.5;
            transform: scale(0.9);
        }

        /* Slot Animations */
        .slot {
            transition: all 0.2s;
        }
        .slot.drag-over {
            background-color: rgba(56, 189, 248, 0.2);
            border-color: #38bdf8;
            transform: scale(1.05);
        }

        /* Particle Effects */
        .particle {
            position: absolute;
            pointer-events: none;
            animation: rise 1s ease-out forwards;
        }
        @keyframes rise {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(0); opacity: 0; }
        }

        /* Shake Effect for Damage */
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* CRT Scanline Effect */
        .crt::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        .integral-symbol {
            font-size: 4rem;
            line-height: 1;
            font-weight: 300;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center crt relative">

    <!-- Game Container -->
    <div id="game-container" class="w-full max-w-5xl h-full max-h-[900px] flex flex-col p-4 relative z-10">
        
        <!-- Header / HUD -->
        <div class="flex justify-between items-start mb-4 bg-slate-900/80 p-4 rounded-xl border border-slate-700 shadow-lg">
            <div>
                <h1 class="text-2xl font-bold text-sky-400 tracking-tighter">INTEGREAT!</h1>
                <div class="text-xs text-slate-400">The Calculus Roguelike</div>
            </div>
            <div class="flex gap-6 text-sm">
                <div class="text-center">
                    <div class="text-slate-400">LEVEL</div>
                    <div id="level-display" class="text-xl font-bold text-white">1</div>
                </div>
                <div class="text-center">
                    <div class="text-slate-400">SCORE</div>
                    <div id="score-display" class="text-xl font-bold text-emerald-400">0</div>
                </div>
                <div class="text-center">
                    <div class="text-slate-400">TARGET</div>
                    <div id="target-display" class="text-xl font-bold text-rose-400">50</div>
                </div>
            </div>
        </div>

        <!-- Main Battle Area -->
        <div class="flex-1 flex gap-4 min-h-0">
            
            <!-- Left: Enemy & Graph -->
            <div class="flex-1 bg-slate-900/90 rounded-xl border border-slate-700 flex flex-col overflow-hidden relative shadow-2xl">
                <!-- Enemy Info -->
                <div class="p-4 bg-slate-800 border-b border-slate-700 flex justify-between items-center">
                    <div>
                        <div class="text-xs text-rose-400 font-bold uppercase tracking-widest">Enemy Function</div>
                        <div id="function-display" class="text-2xl font-bold text-white mt-1 font-serif italic">f(x) = 2x</div>
                    </div>
                    <div class="text-right">
                        <div class="text-xs text-slate-400">HP</div>
                        <div class="w-32 h-4 bg-slate-950 rounded-full overflow-hidden mt-1 border border-slate-600">
                            <div id="hp-bar" class="h-full bg-rose-500 transition-all duration-300" style="width: 100%"></div>
                        </div>
                        <div id="hp-text" class="text-xs mt-1 text-slate-300">100/100</div>
                    </div>
                </div>

                <!-- Canvas Graph -->
                <div class="flex-1 relative bg-[#050505] cursor-crosshair">
                    <canvas id="graph-canvas" class="w-full h-full block"></canvas>
                    <!-- Overlay for math feedback -->
                    <div id="math-feedback" class="absolute top-4 right-4 text-right pointer-events-none opacity-0 transition-opacity duration-300">
                        <div class="text-xs text-slate-400">Antiderivative F(x)</div>
                        <div id="antideriv-display" class="text-xl text-sky-400 font-serif italic">x²</div>
                    </div>
                </div>
            </div>

            <!-- Right: Calculation Station -->
            <div class="w-80 bg-slate-800/90 rounded-xl border border-slate-700 flex flex-col shadow-xl">
                <div class="p-4 border-b border-slate-700 bg-slate-800">
                    <h2 class="text-sm font-bold text-slate-300 uppercase tracking-widest">Integration Console</h2>
                </div>
                
                <div class="flex-1 p-6 flex flex-col items-center justify-center gap-6">
                    
                    <!-- The Integral UI -->
                    <div class="relative flex items-center justify-center py-8 w-full bg-slate-900 rounded-lg border border-slate-700/50">
                        <div class="integral-symbol text-slate-500 font-serif">∫</div>
                        
                        <!-- Bounds Slots -->
                        <div class="absolute -top-2 left-10">
                            <div id="slot-b" class="slot w-12 h-16 bg-slate-800 border-2 border-dashed border-slate-600 rounded flex items-center justify-center text-xl font-bold text-white cursor-pointer hover:border-sky-400 transition-colors" data-slot="b">
                                <span class="text-slate-600 text-xs pointer-events-none">b</span>
                            </div>
                        </div>
                        <div class="absolute -bottom-2 left-10">
                            <div id="slot-a" class="slot w-12 h-16 bg-slate-800 border-2 border-dashed border-slate-600 rounded flex items-center justify-center text-xl font-bold text-white cursor-pointer hover:border-sky-400 transition-colors" data-slot="a">
                                <span class="text-slate-600 text-xs pointer-events-none">a</span>
                            </div>
                        </div>

                        <div class="ml-12 text-2xl font-serif italic text-white" id="integral-inner">
                            f(x) dx
                        </div>
                    </div>

                    <!-- Evaluation Preview -->
                    <div class="w-full space-y-2">
                        <div class="text-xs text-slate-400 uppercase tracking-wider text-center">Fundamental Theorem</div>
                        <div class="bg-slate-950 p-3 rounded border border-slate-700 font-mono text-sm text-center">
                            <span class="text-sky-400">F(b)</span> - <span class="text-purple-400">F(a)</span>
                        </div>
                        <div id="calculation-preview" class="h-8 text-center text-lg font-bold text-white opacity-50">
                            ...
                        </div>
                    </div>

                    <!-- Action Button -->
                    <button id="btn-integrate" class="w-full py-4 bg-sky-600 hover:bg-sky-500 text-white font-bold rounded shadow-lg shadow-sky-900/50 transition-all disabled:opacity-50 disabled:cursor-not-allowed transform active:scale-95" disabled>
                        INTEGRATE!
                    </button>
                    
                    <div id="message-log" class="text-xs text-center text-slate-400 min-h-[1.5em]">
                        Drag cards to bounds
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom: Hand -->
        <div class="mt-4 h-32 relative">
            <div class="absolute inset-0 flex items-center justify-center gap-4 px-8" id="hand-container">
                <!-- Cards injected via JS -->
            </div>
        </div>

    </div>

    <!-- Overlay Screens -->
    <div id="start-screen" class="absolute inset-0 bg-slate-900/95 z-50 flex items-center justify-center flex-col gap-6">
        <h1 class="text-6xl font-bold text-sky-400 tracking-tighter mb-2">INTEGREAT!</h1>
        <p class="text-slate-300 max-w-md text-center">Defeat functions by finding the area under their curves.</p>
        <div class="grid grid-cols-2 gap-4 text-sm text-slate-400 bg-slate-800 p-6 rounded border border-slate-700">
            <div>1. Drag numbers to <span class="text-white">a</span> and <span class="text-white">b</span>.</div>
            <div>2. Calculate Area: <span class="text-sky-400">∫ f(x) dx</span></div>
            <div>3. Area = Damage.</div>
            <div>4. Don't run out of cards!</div>
        </div>
        <button onclick="game.start()" class="px-8 py-3 bg-white text-slate-900 font-bold text-xl rounded hover:bg-sky-400 transition-colors">START INTEGRATING</button>
    </div>

    <div id="game-over-screen" class="hidden absolute inset-0 bg-slate-900/95 z-50 flex items-center justify-center flex-col gap-6">
        <h1 class="text-5xl font-bold text-rose-500 mb-2">LIMIT REACHED</h1>
        <p class="text-xl text-white">Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()" class="px-8 py-3 bg-white text-slate-900 font-bold rounded hover:bg-rose-400 transition-colors">TRY AGAIN</button>
    </div>

    <script>
        // --- MATH ENGINE ---
        // Handles simple polynomials: kx^n
        
        class Term {
            constructor(coeff, power) {
                this.coeff = coeff;
                this.power = power;
            }

            // Integrate: x^n -> (1/n+1)x^(n+1)
            integrate() {
                const newPower = this.power + 1;
                const newCoeff = this.coeff / newPower;
                return new Term(newCoeff, newPower);
            }

            evaluate(x) {
                return this.coeff * Math.pow(x, this.power);
            }

            toString() {
                if (this.coeff === 0) return "";
                if (this.power === 0) return `${this.coeff}`;
                
                let cStr = this.coeff === 1 ? "" : (this.coeff === -1 ? "-" : this.coeff);
                if (this.power === 1) return `${cStr}x`;
                return `${cStr}x^${this.power}`;
            }

            toHTML() {
                if (this.coeff === 0) return "";
                if (this.power === 0) return `${this.coeff}`;
                let cStr = this.coeff === 1 ? "" : (this.coeff === -1 ? "-" : this.coeff);
                if (this.power === 1) return `${cStr}x`;
                return `${cStr}x<sup>${this.power}</sup>`;
            }
        }

        class Polynomial {
            constructor(terms) {
                this.terms = terms; // Array of Term
            }

            integrate() {
                return new Polynomial(this.terms.map(t => t.integrate()));
            }

            evaluate(x) {
                return this.terms.reduce((sum, t) => sum + t.evaluate(x), 0);
            }

            toDisplay() {
                if (this.terms.length === 0) return "0";
                return this.terms.map(t => t.toHTML()).join(" + ").replace(/\+ -/g, "- ");
            }
        }

        // --- GAME STATE ---

        const LEVELS = [
            { terms: [new Term(1, 0)], hp: 10, name: "Constant Line" },         // f(x) = 1
            { terms: [new Term(1, 1)], hp: 25, name: "The Linear slope" },       // f(x) = x
            { terms: [new Term(2, 1)], hp: 40, name: "Steep Slope" },           // f(x) = 2x
            { terms: [new Term(3, 2)], hp: 150, name: "Parabolic Beast" },      // f(x) = 3x^2
            { terms: [new Term(1, 1), new Term(2, 0)], hp: 100, name: "Shifted Line" }, // f(x) = x + 2
            { terms: [new Term(4, 3)], hp: 500, name: "Cubic Crusher" },        // f(x) = 4x^3
            { terms: [new Term(1, 2), new Term(1, 0)], hp: 200, name: "Quadratic Plus" } // f(x) = x^2 + 1
        ];

        class Game {
            constructor() {
                this.levelIndex = 0;
                this.score = 0;
                this.deck = [0, 1, 2, 3, 4, 5, 2, 3, 4, 5, 6, 7];
                this.hand = [];
                this.currentFunction = null; // Polynomial
                this.currentAntideriv = null; // Polynomial
                this.enemyHP = 0;
                this.maxHP = 0;
                
                // Slots
                this.slotA = null;
                this.slotB = null;

                // UI References
                this.canvas = document.getElementById('graph-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('hand-container');
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Bind events
                document.getElementById('btn-integrate').addEventListener('click', () => this.performIntegration());
                
                // Drag and Drop
                this.setupDragDrop();
            }

            start() {
                document.getElementById('start-screen').classList.add('hidden');
                this.loadLevel(0);
                this.drawLoop();
            }

            resizeCanvas() {
                const parent = this.canvas.parentElement;
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight;
                if(this.currentFunction) this.renderGraph();
            }

            loadLevel(index) {
                if (index >= LEVELS.length) {
                    alert("YOU WIN! Calculus Master!");
                    location.reload();
                    return;
                }
                
                this.levelIndex = index;
                const data = LEVELS[index];
                
                // Set up Math
                this.currentFunction = new Polynomial(data.terms);
                this.currentAntideriv = this.currentFunction.integrate();
                
                // Set Stats
                this.maxHP = data.hp;
                this.enemyHP = data.hp;

                // Update UI
                document.getElementById('level-display').innerText = index + 1;
                document.getElementById('function-display').innerHTML = `f(x) = ${this.currentFunction.toDisplay()}`;
                document.getElementById('antideriv-display').innerHTML = this.currentAntideriv.toDisplay();
                document.getElementById('math-feedback').style.opacity = '1';
                
                this.updateHPUI();
                
                // Deal Cards
                this.dealHand();
                
                // Reset slots
                this.clearSlots();
            }

            dealHand() {
                this.container.innerHTML = '';
                // Pick 5 random cards from deck
                const handSize = 5;
                this.hand = [];
                for(let i=0; i<handSize; i++) {
                    const val = this.deck[Math.floor(Math.random() * this.deck.length)];
                    this.hand.push({ id: Math.random().toString(36), value: val });
                }
                this.renderHand();
            }

            renderHand() {
                this.container.innerHTML = '';
                this.hand.forEach(card => {
                    const el = document.createElement('div');
                    el.className = 'card w-16 h-24 bg-white rounded-lg shadow-lg flex items-center justify-center text-3xl font-bold text-slate-800 cursor-grab relative';
                    el.draggable = true;
                    el.dataset.id = card.id;
                    el.dataset.value = card.value;
                    el.innerHTML = `
                        <span class="pointer-events-none">${card.value}</span>
                        <div class="absolute top-1 left-2 text-xs text-slate-400 pointer-events-none">${card.value}</div>
                        <div class="absolute bottom-1 right-2 text-xs text-slate-400 pointer-events-none">${card.value}</div>
                    `;
                    
                    // Drag events
                    el.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', JSON.stringify(card));
                        el.classList.add('dragging');
                    });
                    
                    el.addEventListener('dragend', () => {
                        el.classList.remove('dragging');
                    });

                    this.container.appendChild(el);
                });
            }

            setupDragDrop() {
                ['slot-a', 'slot-b'].forEach(id => {
                    const slot = document.getElementById(id);
                    
                    slot.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        slot.classList.add('drag-over');
                    });

                    slot.addEventListener('dragleave', () => {
                        slot.classList.remove('drag-over');
                    });

                    slot.addEventListener('drop', (e) => {
                        e.preventDefault();
                        slot.classList.remove('drag-over');
                        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                        
                        this.fillSlot(slot.dataset.slot, data);
                    });
                    
                    // Click to remove
                    slot.addEventListener('click', () => {
                        if (slot.dataset.slot === 'a' && this.slotA !== null) this.returnCardToHand(this.slotA);
                        if (slot.dataset.slot === 'b' && this.slotB !== null) this.returnCardToHand(this.slotB);
                        
                        if(slot.dataset.slot === 'a') this.slotA = null;
                        if(slot.dataset.slot === 'b') this.slotB = null;
                        
                        slot.innerHTML = `<span class="text-slate-600 text-xs pointer-events-none">${slot.dataset.slot}</span>`;
                        slot.classList.remove('bg-sky-900', 'border-sky-400');
                        this.updatePreview();
                    });
                });
            }

            fillSlot(type, cardData) {
                // If slot already has a value, return it to hand
                if (type === 'a' && this.slotA) this.returnCardToHand(this.slotA);
                if (type === 'b' && this.slotB) this.returnCardToHand(this.slotB);

                // Set new value
                if (type === 'a') this.slotA = cardData;
                if (type === 'b') this.slotB = cardData;

                // Remove from current hand DOM and Array
                this.hand = this.hand.filter(c => c.id !== cardData.id);
                this.renderHand();

                // Update Slot UI
                const slotEl = document.getElementById(`slot-${type}`);
                slotEl.innerHTML = `<span class="text-3xl text-sky-400 font-bold pointer-events-none">${cardData.value}</span>`;
                slotEl.classList.add('bg-sky-900', 'border-sky-400');

                this.updatePreview();
            }

            returnCardToHand(cardData) {
                this.hand.push(cardData);
                this.renderHand();
            }

            clearSlots() {
                this.slotA = null;
                this.slotB = null;
                ['slot-a', 'slot-b'].forEach(id => {
                    const s = document.getElementById(id);
                    s.innerHTML = `<span class="text-slate-600 text-xs pointer-events-none">${s.dataset.slot}</span>`;
                    s.classList.remove('bg-sky-900', 'border-sky-400');
                });
                this.updatePreview();
            }

            updatePreview() {
                const btn = document.getElementById('btn-integrate');
                const preview = document.getElementById('calculation-preview');
                
                if (this.slotA !== null && this.slotB !== null) {
                    btn.disabled = false;
                    const a = this.slotA.value;
                    const b = this.slotB.value;
                    
                    const Fa = this.currentAntideriv.evaluate(a);
                    const Fb = this.currentAntideriv.evaluate(b);
                    const result = Fb - Fa;

                    preview.innerHTML = `
                        <span class="text-sky-400">${Fb.toFixed(1)}</span> - 
                        <span class="text-purple-400">${Fa.toFixed(1)}</span> = 
                        <span class="text-white font-bold">${result.toFixed(1)}</span>
                    `;
                } else {
                    btn.disabled = true;
                    preview.innerHTML = '...';
                }
            }

            performIntegration() {
                if (this.slotA === null || this.slotB === null) return;

                const a = this.slotA.value;
                const b = this.slotB.value;
                const damage = this.currentAntideriv.evaluate(b) - this.currentAntideriv.evaluate(a);

                // Visual FX
                const feedback = document.createElement('div');
                feedback.className = 'particle text-4xl font-bold text-rose-400 fixed top-1/2 left-1/2 z-50';
                feedback.innerText = `-${damage.toFixed(0)}`;
                document.body.appendChild(feedback);
                setTimeout(() => feedback.remove(), 1000);

                // Logic
                if (damage <= 0) {
                    document.getElementById('message-log').innerText = "Negative/Zero Area deals no damage!";
                    document.getElementById('message-log').className = "text-rose-500 font-bold text-center";
                } else {
                    this.enemyHP -= damage;
                    this.score += Math.floor(damage);
                    document.getElementById('score-display').innerText = this.score;
                    document.getElementById('message-log').innerText = `Integrated from ${a} to ${b} for ${damage.toFixed(1)} damage!`;
                    document.getElementById('message-log').className = "text-emerald-400 font-bold text-center";
                    
                    // Shake effect
                    document.getElementById('game-container').classList.add('shake');
                    setTimeout(() => document.getElementById('game-container').classList.remove('shake'), 500);
                }

                this.updateHPUI();
                
                // Clear and deal new card
                this.clearSlots();
                
                // Keep hand filled
                while(this.hand.length < 5) {
                    const val = this.deck[Math.floor(Math.random() * this.deck.length)];
                    this.hand.push({ id: Math.random().toString(36), value: val });
                }
                this.renderHand();

                // Check Win
                if (this.enemyHP <= 0) {
                    setTimeout(() => {
                        this.levelIndex++;
                        this.loadLevel(this.levelIndex);
                    }, 1000);
                } else {
                    // Check Loss (Run out of effective cards? - Simplified for this version: infinite deck)
                }
            }

            updateHPUI() {
                const pct = Math.max(0, (this.enemyHP / this.maxHP) * 100);
                document.getElementById('hp-bar').style.width = `${pct}%`;
                document.getElementById('hp-text').innerText = `${Math.ceil(this.enemyHP)}/${this.maxHP}`;
            }

            // --- RENDERING ---
            renderGraph() {
                const w = this.canvas.width;
                const h = this.canvas.height;
                const ctx = this.ctx;

                ctx.clearRect(0, 0, w, h);

                // Coordinate System
                const scaleX = w / 10; // Show up to x=10
                const scaleY = h / (this.maxHP > 100 ? 500 : 50); // Adaptive Y scale
                const originY = h - 30;
                const originX = 30;

                // Draw Axes
                ctx.strokeStyle = "#475569";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(originX, 0);
                ctx.lineTo(originX, h);
                ctx.moveTo(0, originY);
                ctx.lineTo(w, originY);
                ctx.stroke();

                // Draw Grid
                ctx.strokeStyle = "#1e293b";
                ctx.lineWidth = 1;
                for(let i=0; i<12; i++) {
                    ctx.beginPath();
                    ctx.moveTo(originX + i*scaleX, 0);
                    ctx.lineTo(originX + i*scaleX, h);
                    ctx.stroke();
                    
                    // Label
                    ctx.fillStyle = "#64748b";
                    ctx.font = "10px monospace";
                    ctx.fillText(i, originX + i*scaleX - 3, originY + 15);
                }

                // Draw Function
                ctx.beginPath();
                ctx.strokeStyle = "#38bdf8"; // Sky 400
                ctx.lineWidth = 3;
                
                let startDraw = false;

                for(let px = 0; px < w; px++) {
                    // Convert pixel x to math x
                    const mathX = (px - originX) / scaleX;
                    if (mathX < 0) continue;

                    const mathY = this.currentFunction.evaluate(mathX);
                    
                    // Convert math y to pixel y
                    const py = originY - (mathY * scaleY);

                    if (!startDraw) {
                        ctx.moveTo(px, py);
                        startDraw = true;
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();

                // Draw Active Area (Integration Zone)
                if (this.slotA !== null && this.slotB !== null) {
                    const a = this.slotA.value;
                    const b = this.slotB.value;
                    
                    const startX = originX + a * scaleX;
                    const endX = originX + b * scaleX;

                    // Create Gradient
                    const grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, "rgba(244, 63, 94, 0.5)"); // Rose
                    grad.addColorStop(1, "rgba(244, 63, 94, 0.1)");

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.moveTo(startX, originY); // Bottom left

                    // Trace curve
                    for(let px = startX; px <= endX; px++) {
                        const mathX = (px - originX) / scaleX;
                        const mathY = this.currentFunction.evaluate(mathX);
                        const py = originY - (mathY * scaleY);
                        ctx.lineTo(px, py);
                    }

                    ctx.lineTo(endX, originY); // Bottom right
                    ctx.closePath();
                    ctx.fill();

                    // Boundary lines
                    ctx.strokeStyle = "#f43f5e";
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(startX, originY);
                    ctx.lineTo(startX, 0);
                    ctx.moveTo(endX, originY);
                    ctx.lineTo(endX, 0);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            drawLoop() {
                this.renderGraph();
                requestAnimationFrame(() => this.drawLoop());
            }
        }

        // Init
        const game = new Game();

    </script>
</body>
</html>